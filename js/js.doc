1.介绍js的基本数据类型。
•	ECMAScript5定义了5种基本数据类型：Number，String，Boolean，undefined，null； 
•	ECMAScript6新增一种基本数据类型：Symbol（ES5的对象属性名均是字符串类型的，会造成属性命名的冲突，symbol是为了解决对象属性名造成冲突，新增的数据类型； symbol值通过symbol函数生成，独一无二，不会产生冲突）
•	ECMAScript6定义了6种基本数据类型：
•	Number，String，Boolean，undefined，null ，Symbol
2.介绍js有哪些内置对象？
•	 Object 是 JavaScript 中所有对象的父对象
•	 数据封装类对象：Object、Array、Boolean、Number 和 String
•	 其他对象：Function、Arguments、Math、Date、RegExp、Error
参考：http://www.ibm.com/developerworks/cn/web/wa-objectsinjs-v1b/index.html
3.说几条写JavaScript的基本规范？
•	 1.不要在同一行声明多个变量。
•	 2.请使用 ===/!==来比较true/false或者数值
•	 3.使用对象字面量替代new Array这种形式
•	 4.不要使用全局函数。
•	 5.Switch语句必须带有default分支
•	 6.函数不应该有时候有返回值，有时候没有返回值。
•	 7.For循环必须使用大括号
•	 8.If语句必须使用大括号
•	 9.for-in循环中的变量 应该使用var关键字明确限定作用域，从而避免作用域污染。
4.JavaScript原型，原型链 ? 有什么特点？
•	1. 原型对象也是普通的对象，是对象一个自带隐式的 __proto__ 属性，原型也有可能有自己的原型，如果一个原型对象的原型不为 null 的话，我们就称之为原型链
•	2. 原型链是由一些用来继承和共享属性的对象组成的（有限的）对象链
•	
•	每个对象都会在其内部初始化一个属性，就是prototype(原型)，当我们访问一个对象的属性时，
•	 如果这个对象内部不存在这个属性，那么他就会去prototype里找这个属性，这个prototype又会有自己的prototype，
•	 于是就这样一直找下去，也就是我们平时所说的原型链的概念。
•	 关系：instance.constructor.prototype = instance.__proto__
•	 特点：
   JavaScript对象是通过引用来传递的，我们创建的每个新对象实体中并没有一份属于自己的原型副本。当我们修改原型时，与之相关的对象也会继承这一改变。
     当我们需要一个属性的时，Javascript引擎会先看当前对象中是否有这个属性， 如果没有的话，
     就会查找他的Prototype对象是否有这个属性，如此递推下去，一直检索到 Object 内建对象。
        function Func(){}
        Func.prototype.name = "Sean";
        Func.prototype.getInfo = function() {
          return this.name;
        }
        var person = new Func();//现在可以参考var person = Object.create(oldObject);
        console.log(person.getInfo());//它拥有了Func的属性和方法
        //"Sean"
        console.log(Func.prototype);
        // Func { name="Sean", getInfo=function()}
5.JavaScript有几种类型的值？，你能画一下他们的内存图吗？
•	 栈：原始数据类型（Undefined，Null，Boolean，Number、String）
•	 堆：引用数据类型（对象、数组和函数）
•	 两种类型的区别是：存储位置不同；
•	 原始数据类型直接存储在栈(stack)中的简单数据段，占据空间小、大小固定，属于被频繁使用数据，所以放入栈中存储；
•	引用数据类型存储在堆(heap)中的对象,占据空间大、大小不固定。如果存储在栈中，将会影响程序运行的性能；引用数据类型在栈中存储了指针，该指针指向堆中该实体的起始地址。当解释器寻找引用值时，会首先检索其在栈中的地址，取得地址后从堆中获得实体
6.如何将字符串转化为数字，例如'12.3b'?
•	  * parseFloat('12.3b');
•	  * 正则表达式，'12.3b'.match(/(\d)+(\.)?(\d)+/g)[0] * 1, 但是这个不太靠谱，提供一种思路而已。
7.如何将浮点数点左边的数每三位添加一个逗号，如12000000.11转化为『12,000,000.11』?
•	  function commafy(num){
•	      return num && num
•	          .toString()
•	          .replace(/(\d)(?=(\d{3})+\.)/g, function($1, $2){
•	              return $2 + ',';
•	          });
•	   }
8.如何实现数组的随机排序？
•	  方法一：
•	      var arr = [1,2,3,4,5,6,7,8,9,10];
•	      function randSort1(arr){
•	          for(var i = 0,len = arr.length;i < len; i++ ){
•	              var rand = parseInt(Math.random()*len);
•	              var temp = arr[rand];
•	              arr[rand] = arr[i];
•	              arr[i] = temp;
•	          }
•	          return arr;
•	      }
•	      console.log(randSort1(arr));
•	  方法二：
•	      var arr = [1,2,3,4,5,6,7,8,9,10];
•	      function randSort2(arr){
•	          var mixedArray = [];
•	          while(arr.length > 0){
•	              var randomIndex = parseInt(Math.random()*arr.length);
•	              mixedArray.push(arr[randomIndex]);
•	              arr.splice(randomIndex, 1);
•	          }
•	          return mixedArray;
•	      }
•	      console.log(randSort2(arr));
•	  方法三：
•	      var arr = [1,2,3,4,5,6,7,8,9,10];
•	      arr.sort(function(){
•	          return Math.random() - 0.5;
•	      })
•	      console.log(arr);
9.Javascript如何实现继承？
•	 1、构造继承
•	 2、原型继承
•	 3、实例继承
•	 4、拷贝继承
•	 原型prototype机制或apply和call方法去实现较简单，建议使用构造函数与原型混合方式。
•	     function Parent(){
•	         this.name = 'wang';
•	     }
•	     function Child(){
•	         this.age = 28;
•	     }
•	     Child.prototype = new Parent();//继承了Parent，通过原型
•	     var demo = new Child();
•	     alert(demo.age);
•	     alert(demo.name);//得到被继承的属性
10.JavaScript继承的几种实现方式？
•	原型链继承，借用构造函数继承，组合继承(原型+借用构造)，原型式继承，寄生式继承，寄生组合式继承
o	参考：构造函数的继承，非构造函数的继承；
o	原型链继承
 
问题：
1.引用类型的属性被所有实例共享，举个例子：
 
2.在创建child实例时，不能Parent传参
o	借用构造函数（经典继承）
 
优点：
1. 避免了引用类型的属性被所有实例共享
2. 可以在child中向Parent传参
举个例子：
 
缺点：
方法都在构造函数中定义，每次创建实例都会创建一边方法 
o	组合继承
原型链继承和经典继承双剑合璧
 
优点：融合原型链继承和构造函数的优点，是javascript中最常用的继承模式。
11.javascript创建对象的几种方式？
 javascript创建对象简单的说,无非就是使用内置对象或各种自定义对象，当然还可以用JSON；但写法有很多种，也能混合使用。
    1、对象字面量的方式
        person={firstname:"Mark",lastname:"Yun",age:25,eyecolor:"black"};
    2、用function来模拟无参的构造函数
        function Person(){}
        var person=new Person();//定义一个function，如果使用new"实例化",该function可以看作是一个Class
        person.name="Mark";
        person.age="25";
	person.work=function(){
        alert(person.name+" hello...");
        }
        person.work();
    3、用function来模拟参构造函数来实现（用this关键字定义构造的上下文属性）
        function Pet(name,age,hobby){
           this.name=name;//this作用域：当前对象
           this.age=age;
           this.hobby=hobby;
           this.eat=function(){
              alert("我叫"+this.name+",我喜欢"+this.hobby+",是个程序员");
           }
 }
        var maidou =new Pet("麦兜",25,"coding");//实例化、创建对象
        maidou.eat();//调用eat方法
    4、用工厂方式来创建（内置对象）
         var wcDog =new Object();
         wcDog.name="旺财";
         wcDog.age=3;
 wcDog.work=function(){
           alert("我是"+wcDog.name+",汪汪汪......");
         }
         wcDog.work();
    5、用原型方式来创建
        function Dog(){}
         Dog.prototype.name="旺财";
         Dog.prototype.eat=function(){
         alert(this.name+"是个吃货");
         }
         var wangcai =new Dog();
         wangcai.eat();
    5、用混合方式来创建
        function Car(name,price){
          this.name=name;
          this.price=price;
}
Car.prototype.sell=function(){
           alert("我是"+this.name+"，我现在卖"+this.price+"万元");
          }
        var camry =new Car("凯美瑞",27);
        camry.sell();
12.Javascript作用链域?
•	 全局函数无法查看局部函数的内部细节，但局部函数可以查看其上层的函数细节，直至全局细节。
•	 当需要从局部函数查找某一属性或方法时，如果当前作用域没有找到，就会上溯到上层作用域查找，直至全局函数，这种组织形式就是作用域链。
13.谈谈This对象的理解。
o	this总是指向函数的直接调用者（而非间接调用者）；
o	如果有new关键字，this指向new出来的那个对象；
o	在事件中，this指向触发这个事件的对象，特殊的是，IE中的attachEvent中的this总是指向全局对象Window；
14.eval是做什么的？
•	 它的功能是把对应的字符串解析成JS代码并运行；
•	 应该避免使用eval，不安全，非常耗性能（2次，一次解析成js语句，一次执行）。
•	 由JSON字符串转换为JSON对象的时候可以用eval，var obj =eval('('+ str +')');
15.什么是window对象? 什么是document对象?
•	 window对象是指浏览器打开的窗口。
•	document对象是Documentd对象（HTML 文档对象）的一个只读引用，window对象的一个属性。
16.null，undefined 的区别？
•	 null         表示一个对象是“没有值”的值，也就是值为“空”；
•	 undefined     表示一个变量声明了没有初始化(赋值)； 
•	 undefined不是一个有效的JSON，而null是；
•	 undefined的类型(typeof)是undefined；
•	 null的类型(typeof)是object；
    Javascript将未赋值的变量默认值设为undefined；
    Javascript从来不会将变量设为null。它是用来让程序员表明某个用var声明的变量时没有值的。
    typeof undefined
        //"undefined"
	undefined :是一个表示"无"的原始值或者说表示"缺少值"，就是此处应该有一个值，但是还没有定义。当尝试读取时会返回 undefined；
        例如变量被声明了，但没有赋值时，就等于undefined
    typeof null
        //"object"
        null : 是一个对象(空对象, 没有任何属性和方法)；
        例如作为函数的参数，表示该函数的参数不是对象； 
    注意：
        在验证null时，一定要使用　=== ，因为 == 无法分别 null 和　undefined
         null == undefined // true
          null === undefined // false
    再来一个例子： 
        null
        Q：有张三这个人么？
        A：有！
        Q：张三有房子么？
        A：没有！ 
        undefined
        Q：有张三这个人么？
        A：有！
        Q: 张三有多少岁？
        A: 不知道（没有被告诉）
参考阅读：[undefined与null的区别](http://www.ruanyifeng.com/blog/2014/03/undefined-vs-null.html)
17.写一个通用的事件侦听器函数。
•	     // event(事件)工具集，来源：github.com/markyun
•	     markyun.Event = {
•	         // 页面加载完成后
•	         readyEvent : function(fn) {
•	             if (fn==null) {
•	                 fn=document;
•	             }
•	             var oldonload = window.onload;
•	             if (typeof window.onload != 'function') {
•	                 window.onload = fn;
•	             } else {
•	                 window.onload = function() {
•	                     oldonload();
•	                     fn();
•	                 };
•	             }
•	         },
•	         // 视能力分别使用dom0||dom2||IE方式 来绑定事件
•	         // 参数： 操作的元素,事件名称 ,事件处理程序
•	             addEvent : function(element, type, handler) {
•	             if (element.addEventListener) {
•	                 //事件类型、需要执行的函数、是否捕捉
•	             element.addEventListener(type, handler, false);
•	             } else if (element.attachEvent) {
•	                 element.attachEvent('on' + type, function() {
•	                     handler.call(element);
•	                 });
•	             } else {
•	                 element['on' + type] = handler;
•	             }
•	         },
•	         // 移除事件
•	         removeEvent : function(element, type, handler) {
•	             if (element.removeEventListener) {
•	                 element.removeEventListener(type, handler, false);
•	             } else if (element.datachEvent) {
•	                 element.detachEvent('on' + type, handler);
•	             } else {
•	                 element['on' + type] = null;
•	             }
•	         },
•	         // 阻止事件 (主要是事件冒泡，因为IE不支持事件捕获)
•	         stopPropagation : function(ev) {
•	              if (ev.stopPropagation) {
•	                 ev.stopPropagation();
•	             } else {
•	                 ev.cancelBubble = true;
•	             }
•	         },
•	         // 取消事件的默认行为
•	         preventDefault : function(event) {
•	             if (event.preventDefault) {
•	                 event.preventDefault();
•	             } else {
•	                 event.returnValue = false;
•	             }
•	         },
•	         // 获取事件目标
•	         getTarget : function(event) {
•	             return event.target || event.srcElement;
•	         },
•	         // 获取event对象的引用，取到事件的所有信息，确保随时能使用event；
•	         getEvent : function(e) {
•	             var ev = e || window.event;
•	             if (!ev) {
•	                 var c = this.getEvent.caller;
•	                 while (c) {
•	                     ev = c.arguments[0];
•	                     if (ev && Event == ev.constructor) {
•	                         break;
•	                     }
•	                     c = c.caller;
•	                 }
•	             }
•	             return ev;
•	         }
•	     };
18.["1", "2", "3"].map(parseInt) 答案是多少？
•	 parseInt() 函数能解析一个字符串，并返回一个整数，需要两个参数 (val, radix)，
•	 其中 radix 表示要解析的数字的基数。【该值介于 2 ~ 36 之间，并且字符串中的数字不能大于radix才能正确返回数字结果值】;
•	 但此处 map 传了 3 个 (element, index, array),我们重写parseInt函数测试一下是否符合上面的规则。
•	 function parseInt(str, radix) {
•	     return str+'-'+radix;
•	 };
•	 var a=["1", "2", "3"];
•	 a.map(parseInt);  // ["1-0", "2-1", "3-2"] 不能大于radix
•	 因为二进制里面，没有数字3,导致出现超范围的radix赋值和不合法的进制解析，才会返回NaN
•	 所以["1", "2", "3"].map(parseInt) 答案也就是：[1, NaN, NaN]
详细解析：http://blog.csdn.net/justjavac/article/details/19473199
19.事件是？IE与火狐的事件机制有什么区别？ 如何阻止冒泡和默认事件？
•	  1. 我们在网页中的某个操作（有的操作对应多个事件）。例如：当我们点击一个按钮就会产生一个事件。是可以被 JavaScript 侦测到的行为。
•	  2. 事件处理机制：IE是事件冒泡、Firefox同时支持两种事件模型，也就是：捕获型事件和冒泡型事件；
•	  3. ev.stopPropagation();//标准浏览器阻止事件冒泡
•	（旧ie的方法 ev.cancelBubble = true;） //ie9之前
•	  4.阻止默认事件：
•	  为了不让a点击之后跳转，我们就要给他的点击事件进行阻止
•	  return false
•	  e.preventDefault();
20.什么是闭包（closure），为什么要用它？
•	 闭包是指有权访问另一个函数作用域中变量的函数，创建闭包的最常见的方式就是在一个函数内创建另一个函数，通过另一个函数访问这个函数的局部变量,利用闭包可以突破作用链域，将函数内部的变量和方法传递到外部。
•	总的来说就是：内层作用域可以访问外层作用域的变量
•	闭包的特性： 
•	 1.函数内再嵌套函数
•	 2.内部函数可以引用外层的参数和变量
•	 3.参数和变量不会被垃圾回收机制回收
•	 //li节点的onclick事件都能正确的弹出当前被点击的li索引
•	  <ul id="testUL">
•	     <li> index = 0</li>
•	     <li> index = 1</li>
•	     <li> index = 2</li>
•	     <li> index = 3</li>
•	 </ul>
•	 <script type="text/javascript">
•	       var nodes = document.getElementsByTagName("li");
•	     for(i = 0;i<nodes.length;i+= 1){
•	         nodes[i].onclick = (function(i){
•	                   return function() {
•	                      console.log(i);
•	                    } //不用闭包的话，值每次都是4
•	                 })(i);
•	     }
•	 </script>
    执行say667()后,say667()闭包内部变量会存在,而闭包内部函数的内部变量不会存在
    使得Javascript的垃圾回收机制GC不会收回say667()所占用的资源
    因为say667()的内部函数的执行需要依赖say667()中的变量
    这是对闭包作用的非常直白的描述
      function say667() {
        // Local variable that ends up within closure
        var num = 666;
        var sayAlert = function() {
            alert(num);
        }
        num++;
        return sayAlert;
    }
     var sayAlert = say667();
     sayAlert()//执行结果应该弹出的667
21.javascript 代码中的"use strict";是什么意思 ? 使用它区别是什么？
•	 use strict是一种ECMAscript 5 添加的（严格）运行模式,这种模式使得 Javascript 在更严格的条件下运行, 
•	 使JS编码更加规范化的模式,消除Javascript语法的一些不合理、不严谨之处，减少一些怪异行为。
•	 默认支持的糟糕特性都会被禁用，比如不能用with，也不能在意外的情况下给全局变量赋值;
•	 全局变量的显示声明,函数必须声明在顶层，不允许在非函数代码块内声明函数,arguments.callee也不允许使用；
•	 消除代码运行的一些不安全之处，保证代码运行的安全,限制函数中的arguments修改，严格模式下的eval函数的行为和非严格模式的也不相同; 
•	 提高编译器效率，增加运行速度；
•	 为未来新版本的Javascript标准化做铺垫。
22.如何判断一个对象是否属于某个类？
•	    使用instanceof （待完善）
•	    if(a instanceof Person){
•	        alert('yes');
•	   }
23.new操作符具体干了什么呢?
•	  1、创建一个空对象，并且 this 变量引用该对象，同时还继承了该函数的原型。
•	  2、属性和方法被加入到 this 引用的对象中。
•	  3、新创建的对象由 this 所引用，并且最后隐式的返回 this 。
•	 var obj  = {};
•	 obj.__proto__ = Base.prototype;
•	 Base.call(obj);
24. 怎么让Chrome支持小于12px的文字？
•	针对谷歌浏览器内核，加webkit前缀，用transform:scale()这个属性进行缩放
•	p sapn{
•	font-size:10px;
•	-webkit-transform:scale(0.8);
•	display:block;
•	}
25.Javascript中，有一个函数，执行时对象查找时，永远不会去查找原型，这个函数是？
•	 hasOwnProperty
•	 javaScript中hasOwnProperty函数方法是返回一个布尔值，指出一个对象是否具有指定名称的属性。此方法无法检查该对象的原型链中是否具有该属性；该属性必须是对象本身的一个成员。
•	 使用方法：
•	 object.hasOwnProperty(proName)
•	 其中参数object是必选项。一个对象的实例。
•	 proName是必选项。一个属性名称的字符串值。
•	如果 object 具有指定名称的属性，那么JavaScript中hasOwnProperty函数方法返回 true，反之则返回 false。
26.JSON 的了解？
•	 JSON(JavaScript Object Notation) 是一种轻量级的数据交换格式。
•	 它是基于JavaScript的一个子集。数据格式简单, 易于读写, 占用带宽小
•	 如：{"age":"12", "name":"back"}
•	 JSON字符串转换为JSON对象:
•	 var obj =eval('('+ str +')');
•	 var obj = str.parseJSON();
•	 var obj = JSON.parse(str); 
•	 JSON对象转换为JSON字符串：
•	 var last=obj.toJSONString();
•	 var last=JSON.stringify(obj);
27.能解释一下这段代码的意思吗？
[].forEach.call($$("*"),function(a){a.style.outline="1px solid #"+(~~(Math.random()*(1<<24))).toString(16)})
•	这段代码是首先获取了所有的页面元素，然后使用一个不同的颜色为他们添加一个1px的边框。
•	$$相当于document.querySelectorAll,可以用document.querySelectorAll(‘*’)来代替$$("*")；
•	~~的作用就相当于parseInt
•	1<<24：1向左移24位，也就是2的24次方
•	toString(16)：把数字转换成16进制的字符串
28.js延迟加载的方式有哪些？
•	 defer和async、动态创建DOM方式（用得最多）、按需异步载入js
29.Ajax 是什么? 如何创建一个Ajax？
•	 ajax的全称：Asynchronous Javascript And XML。
•	 异步传输+js+xml。
•	 所谓异步，在这里简单地解释就是：向服务器发送请求的时候，我们不必等待结果，而是可以同时做其他的事情，等到有了结果它自己会根据设定进行后续操作，与此同时，页面是不会发生整页刷新的，提高了用户体验。
•	 (1)创建XMLHttpRequest对象,也就是创建一个异步调用对象
•	 (2)创建一个新的HTTP请求,并指定该HTTP请求的方法、URL及验证信息
•	 (3)设置响应HTTP请求状态变化的函数
•	 (4)发送HTTP请求
•	 (5)获取异步调用返回的数据
•	 (6)使用JavaScript和DOM实现局部刷新
30.Ajax 解决浏览器缓存问题？
•	  1、在ajax发送请求前加上 anyAjaxObj.setRequestHeader("If-Modified-Since","0")。
•	  2、在ajax发送请求前加上 anyAjaxObj.setRequestHeader("Cache-Control","no-cache")。
•	  3、在URL后面加上一个随机数： "fresh=" + Math.random();。
•	  4、在URL后面加上时间搓："nowtime=" + new Date().getTime();。
•	  5、如果是使用jQuery，直接这样就可以了 $.ajaxSetup({cache:false})。这样页面的所有ajax都会执行这条语句就是不需要保存缓存记录。
31.同步和异步的区别?
同步的概念应该是来自于OS中关于同步的概念:不同进程为协同完成某项工作而在先后次序上调整(通过阻塞,唤醒等方式).同步强调的是顺序性.谁先谁后.异步则不存在这种顺序性.
同步：浏览器访问服务器请求，用户看得到页面刷新，重新发请求,等请求完，页面刷新，新内容出现，用户看到新内容,进行下一步操作。
异步：浏览器访问服务器请求，用户正常操作，浏览器后端进行请求。等请求完，页面不刷新，新内容也会出现，用户看到新内容。
（待完善）
32.如何解决跨域问题?
 jsonp、 iframe、window.name、window.postMessage、服务器上设置代理页面
33.页面编码和被请求的资源编码如果不一致如何处理？
34.模块化开发怎么做？
立即执行函数,不暴露私有成员
     var module1 = (function(){
     　　　　var _count = 0;
     　　　　var m1 = function(){
		//...
     　　　　};
     　　　　var m2 = function(){
     　　　　　　//...
     　　　　};
     　　　　return {
     　　　　　　m1 : m1,
     　　　　　　m2 : m2
     　　　　};
     　　})();
理解模块化开发模式：浏览器端requirejs，seajs；服务器端nodejs；ES6模块化；fis、webpack等前端整体模块化解决方案；grunt、gulp等前端工作流的使用
35.AMD（Modules/Asynchronous-Definition）、CMD（Common Module Definition）规范区别？
AMD 规范在这里：https://github.com/amdjs/amdjs-api/wiki/AMD
CMD 规范在这里：https://github.com/seajs/seajs/issues/242
 Asynchronous Module Definition，异步模块定义，所有的模块将被异步加载，模块加载不影响后面语句运行。所有依赖某些模块的语句均放置在回调函数中。
  区别： 
     1. 对于依赖的模块，AMD 是提前执行，CMD 是延迟执行。不过 RequireJS 从 2.0 开始，也改成可以延迟执行（根据写法不同，处理方式不同）。CMD 推崇 as lazy as possible.
     2. CMD 推崇依赖就近，AMD 推崇依赖前置。看代码： 
 // CMD
 define(function(require, exports, module) {
     var a = require('./a')
     a.doSomething()
     // 此处略去 100 行
     var b = require('./b') // 依赖可以就近书写
     b.doSomething()
     // ...
 })
 // AMD 默认推荐
 define(['./a', './b'], function(a, b) { // 依赖必须一开始就写好
     a.doSomething()
     // 此处略去 100 行
     b.doSomething()
     // ...
 })
36.requireJS的核心原理是什么？（如何动态加载的？如何避免多次加载的？如何缓存的？）
核心是js的加载模块，通过正则匹配模块以及模块的依赖关系，保证文件加载的先后顺序，根据文件的路径对加载过的文件做了缓存
 参考：http://annn.me/how-to-realize-cmd-loader/
37.JS模块加载器的轮子怎么造，也就是如何实现一个模块加载器？
38.谈一谈你对ECMAScript6的了解？
•	ES6新的语法糖，类，模块化等新特性
39.ECMAScript6 怎么写class么，为什么会出现class这种东西?
40.异步加载JS的方式有哪些？
•	   (1) defer，只支持IE
•	   (2) async： 
•	   (3) 创建script，插入到DOM中，加载完毕后callBack
41.documen.write和 innerHTML的区别
•	  document.write只能重绘整个页面
•	  innerHTML可以重绘页面的一部分
42.DOM操作——怎样添加、移除、移动、复制、创建和查找节点?
•	  （1）创建新节点
•	    createDocumentFragment()    //创建一个DOM片段
•	    createElement()   //创建一个具体的元素
•	    createTextNode()   //创建一个文本节点
•	  （2）添加、移除、替换、插入
•	    appendChild()
•	    removeChild()
•	    replaceChild()
•	    insertBefore() //在已有的子节点前插入一个新的子节点
•	  （3）查找
•	    getElementsByTagName()    //通过标签名称
•	    getElementsByName()    //通过元素的Name属性的值(IE容错能力较强，会得到一个数组，其中包括id等于name值的)
•	   getElementById()    //通过元素Id，唯一性
43..call() 和 .apply() 的区别？
•	call和apply相同点：
•	  都是为了用一个本不属于一个对象的方法，让这个对象去执行
•	  toString.call([],1,2,3)
•	  toString.apply([],[1,2,3])
•	  Object.call(this,obj1,obj2,obj3)
•	  Object.apply(this,arguments)
•	区别：call第二个参数开始接受一个参数列表
•	      apply第二个参数开始接受一个参数数组 
44.数组和对象有哪些原生方法，列举一下？
45.JS怎么实现一个类。怎么实例化这个类
46.JavaScript中的作用域与变量声明提升？
47.如何编写高性能的Javascript？
•	1、字节对齐
•	2、按Cache Line长度将数据按照操作分段存放
•	3、对一次函数集操作所需的数据尽量集中，减少访问内存的数量，也就说访问变量A的时候，后续要使用的变量B、C、D也在cache line中了。减少调入一个Cache Line只使用其中几个字节的情况。同时在一次外层循环处理到多个SGP、eNodeB的消息时，重复访问的公共数据还留在cache中
•	4、大函数，减少小函数的调用开销
•	5、减少不必要的初始化，异常检查
•	6、避免数据定义不恰当导致Cache collision的情况， Cache miss和分支预测作为重点审视，可以在代码检视时，或者之后小汤利用工具协助排查cache miss比较高的地方
•	7、当然，好的数据结构，局部细节处理方式
48.内存泄露是什么？哪些操作会造成内存泄漏？
•	1.内存泄漏指任何对象在您不再拥有或需要它之后仍然存在。
•	垃圾回收器定期扫描对象，并计算引用了每个对象的其他对象的数量。如果一个对象的引用数量为 0（没有其他对象引用过该对象），或对该对象的惟一引用是循环的，那么该对象的内存即可回收。
•	2.引起内存泄漏的主要原因：
•	(1)循环引用：当DOM对象与任何JS对象相互引用时，就很容易形成内存泄漏；
•	(2)JS闭包引起内存泄漏：一个内部的函数总是可以访问这个函数外部的变量和参数，甚至在外部的函数返回之后。
•	(3)动态创建大量DOM元素时，因为新增插入DOM元素的顺序不恰当，造成泄漏。
•	setTimeout 的第一个参数使用字符串而非函数的话，会引发内存泄漏。
49. 使用JS实现获取文件扩展名？
•	  function getFileExtension(filename) {
•	    return filename.slice((filename.lastIndexOf(".") - 1 >>> 0) + 2);
•	  }
•	  String.lastIndexOf() 方法返回指定值（本例中的'.'）在调用该方法的字符串中最后出现的位置，如果没找到则返回 -1。
•	  对于'filename'和'.hiddenfile'，lastIndexOf的返回值分别为0和-1无符号右移操作符(»>) 将-1转换为4294967295，将-2转换为4294967294，这个方法可以保证边缘情况时文件名不变。
•	  String.prototype.slice() 从上面计算的索引处提取文件的扩展名。如果索引比文件名的长度大，结果为""。
50. javascript的typeof返回哪些数据类型
•	object number function boolean underfind string 
•	typeof isNaN 
•	检测数组的几种方式：
•	Array.isArray(); es5
•	toString.call([]);//”[object Array]”
•	var arr=[];
•	arr.constructor;//Array
•	instanceof Array
51、传统事件绑定和符合W3C标准的事件绑定有什么区别？
•	<div onclick=””>123</div>
•	div1.onclick=function(){};
•	<button  onmouseover=””></button>
•	1、如果说给同一个元素绑定了两次或者多次相同类型的事件，那么后面的绑定会覆盖前面的绑定
•	2、不支持DOM事件流 事件捕获阶段è目标元素阶段=>事件冒泡阶段
•	符合W3C标准的事件绑定的方式 addEventListener/attachEvent
•	A、非IE浏览器：
•	addEventListener
•	1、 如果说给同一个元素绑定了两次或者多次相同类型的事件，所以的绑定将会依次触发
•	2、 支持DOM事件流的
•	3、 进行事件绑定传参不需要on前缀
•	addEventListener(“click”,function(){},true);//此时的事件就是在事件捕获阶段执行
•	第三个参数：代表是否在捕获阶段执行，默认值是false
•	addEventListener(“click”,function(e){
•	})
•	addEventListener(“click”,function(){},false) 事件在冒泡阶段执行
•	B、IE浏览器
•	ie9开始，ie11 edge：addEventListener
•	ie9以前 ie8：attachEvent/detachEvent
•	1、 进行事件类型传参需要带上on前缀
•	dom1.attachEvent(“onclick”,functioin(){});
•	2、 这种方式只支持事件冒泡，不支持事件捕获
52、IE和标准下有哪些兼容性的写法
•	ev = ev || window.event è获取触发事件的对象
•	var target = ev.srcElement||ev.target  à获取事件的源对象
•	document.documentElement.clientWidth || document.body.clientWidth
53.javascript的同源策略
•	一段脚本只能读取来自于同一来源的窗口和文档的属性，这里的同一来源指的是主机名、协议和端口号的组合
•	协议：http,ftp https
•	主机名；localhost 127.0.0.1
•	端口名：80:
•	127.0.0.1:1011
•	http协议的默认端口：80
•	https:协议的默认端口是8083
•	同源策略带来的麻烦：ajax在不同域名下的请求无法实现，
•	如果说想要请求其他来源的js文件，或者json数据，那么可以通过jsonp来解决
54. 编写一个数组去重的方法
•	[1,3,1,5,2,3,7]=>[1,3,5,2,7]
•	方法1：
•	1、 先创建一个空数组，用来保存最终的结果
•	2、 循环原数组中的每个元素
•	3、 再对每个元素进行二次循环，判断是否有与之相同的元素，如果没有，将把这个元素放到新数组中
•	4、 返回这个新数组 
•	方法2：
•	数组的indexOf()方法返回给定元素能找在数组中找到的第一个索引值，否则返回-1。 
•	Array.prototype.unique2 = function()
•	{
•	var n = []; //一个新的临时数组
•	for(var i = 0; i < this.length; i++) //遍历当前数组
•	{
•	//如果当前数组的第i已经保存进了临时数组，那么跳过，
•	//否则把当前项push到临时数组里面
•	if (n.indexOf(this[i]) == -1) n.push(this[i]);
•	}
•	return n;
•	}
10、JavaScript是一门什么样的语言，它有哪些特点？
•	没有标准答案。
•	运行环境：浏览器中的JS引擎（v8.。。 ff:splidemonkey）
•	运行在Node.js：v8引擎上
•	语言特性：面向对象（创建对象的多种方式，继承的多种方式、原型链），动态语言
•	//动态语言的特性
•	var num=10;//num是一个数字类型
•	num="jim";//此时num又变成一个字符串类型
•	//我们把一个变量用来保存不同数据类型的语言称之为一个动态语言，或者说是一个弱类型语言
•	//静态语言：c# Java c c++
•	//静态语言在声明一个变量就已经确定了这个变量的数据类型，
•	int c;//c就是整数类型//我们把这种声明一个变量就确定了它的数据类型这样的语言称之为静态语言，也称之为强类型语言
•	//  而且在任何时候都不可以改变他的数据类型
11、如何检测数组的数据类型
•	方法一、判断其是否具有“数组性质”，如slice()方法。可自己给该变量定义slice方法，故有时会失效
•	方法二、obj instanceof Array 在某些IE版本中不正确
•	方法三、toString.call([]);//”[object Array]”
•	方法四、方法一二皆有漏洞，在ECMA Script5中定义了新方法Array.isArray(), 保证其兼容性，最好的方法如下：
•	if(typeof Array.isArray==="undefined"){
•	    Array.isArray = function(arg){
•	        return Object.prototype.toString.call(arg)==="[object Array]"
•	    };
•	}
12、希望获取到页面中所有的checkbox怎么做 
•	var domList = document.getElementsByTagName(‘input’)
•	var checkBoxList = [];//返回的所有的checkbox
•	var len = domList.length;　　//缓存到局部变量
•	while (len--) {
•	    if (domList[len].type == ‘checkbox’) {
•	    　　checkBoxList.push(domList[len]);
•	　　}
•	}
13、Javascript的事件流模型都有什么？ DOM事件流
•	“事件冒泡”：事件开始由最具体的元素接受，然后逐级向上传播
•	“事件捕捉”：事件由最不具体的节点先接收，然后逐级向下，一直到最具体的
•	“DOM事件流”：三个阶段：事件捕捉，目标阶段，事件冒泡
14、看下列代码输出为何？解释原因。
•	var a;
•	alert(typeof a); // “undefined”
•	//alert(b); // 报错 
•	b=10;
•	alert(typeof b);//”number” 
•	undefined会在以下三种情况下产生：
•	a、一个变量定义了却没有被赋值
•	b、想要获取一个对象上不存在的属性或者方法:
•	c、一个数组中没有被赋值的元素
15、看代码给答案。 
•	var a = new Object();
•	a.value = 1;
•	b = a;
•	b.value = 2;
•	alert(a.value);//2
•	答案：2（考察引用数据类型细节）
•	 
16、var numberArray = [3,6,2,4,1,5]; （考察基础API）
•	1) 实现对该数组的倒排，反转，输出[5,1,4,2,6,3]
•	reverse()
•	2) 实现对该数组的降序排列，输出[6,5,4,3,2,1]
•	冒泡排序
17、输出今天的日期，以YYYY-MM-DD的方式，比如今天是2014年9月26日，则输出2014-09-26 
•	var d = new Date();
•	// 获取年，getFullYear()返回4位的数字 //今年：2016
•	var year = d.getFullYear();
•	// 获取月，月份比较特殊，0是1月，11是12月
•	var month = d.getMonth() + 1;
•	// 变成两位
•	month = month < 10 ? '0' + month : month;
•	// 获取日
•	var day = d.getDate();
•	day = day < 10 ? '0' + day : day;
•	alert(year + '-' + month + '-' + day);
 18、将字符串”<tr><td>{$id}</td><td>{$name}</td></tr>”中的{$id}替换成10，{$name}替换成Tony （使用正则表达式）
•	答案：”<tr><td>{$id}</td><td>{$id}_{$name}</td></tr>”.replace(/{\$id}/g, ’10′).replace(/{\$name}/g, ‘Tony’);
19、foo = foo||bar ，这行代码是什么意思？为什么要这样写？
•	这种写法称之为短路表达式
•	答案：if(!foo) foo = bar; //如果foo存在，值不变，否则把bar的值赋给foo。
•	短路表达式：作为”&&”和”||”操作符的操作数表达式，这些表达式在进行求值时，只要最终的结果已经可以确定是真或假，求值过程便告终止，这称之为短路求值。
•	注意if条件的真假判定，记住以下是false的情况：
•	空字符串、false、undefined、null、0 
20、看下列代码，将会输出什么?( 变量声明提前 
•	var foo = 1;
•	function(){
•	    var foo;
•	    console.log(foo); //undefined
•	    foo = 2;
•	    console.log(foo); // 2;  
•	}
•	函数声明与变量声明会被JavaScript引擎隐式地提升到当前作用域的顶部，但是只提升名称不会提升赋值部分。
21、有这样一个URL：http://item.taobao.com/item.htm?a=1&b=2&c=&d=xxx&e，请写一段JS程序提取URL中的各个GET参数(参数名和参数个数不确定)，将其按key-value形式返回到一个json结构中，如{a:’1′, b:’2′, c:”, d:’xxx’, e:undefined}。
22、
a、看下面代码，给出输出结果。
•	for(var i=1;i<=3;i++){
•	  setTimeout(function(){
•	      console.log(i);   
•	  },0); 
•	};
•	答案：4 4 4。
•	原因：setTimeout会在js引擎空闲的时候再执行
•	 Javascript事件处理器在线程空闲之前不会运行。追问，
b、如果让a中代码输出1 2 3？
•	for(var i=1;i<=3;i++){
•	   setTimeout((function(a){  //改成立即执行函数
•	       console.log(a);   
•	   })(i),0); 
•	};
23、写一个function，清除字符串前后的空格。（兼容所有浏览器）
•	使用自带接口trim()，考虑兼容性： 
•	if (!String.prototype.trim) {
•	 String.prototype.trim = function() {
•	 return this.replace(/^\s+/, "").replace(/\s+$/,"");
•	//\s匹配空白字符：回车、换行、制表符tab 空格
•	 }
•	}
•	 // test the function
•	var str = " \t\n test string ".trim();
•	alert(str == "test string"); // alerts "true"
24、Javascript中callee和caller的作用？
•	arguments.callee：获得当前函数的引用 
•	caller是返回一个对函数的引用，该函数调用了当前函数；如果不是由其他函数调用的，那么返回值就是null
•	callee是返回正在被执行的function函数，也就是所指定的function对象的正文。
•	那么问题来了？
•	如果一对兔子每月生一对兔子；一对新生兔，从第二个月起就开始生兔子；假定每对兔子都是一雌一雄，试问一对兔子，第n个月能繁殖成多少对兔子？（使用callee完成）
25、Javascript中, 以下哪条语句一定会产生运行错误？      答案(  BC   ) 
•	A、var _变量=NaN;
•	B、var 0bj = [];(这里是一个数字0)
•	C、var obj = //; 
•	D、var obj = {};
26、以下两个变量a和b，a+b的哪个结果是NaN？      答案(   C  )
•	A、var a=undefind; b=NaN          //拼写 undefined
•	B、var a=‘123’; b=NaN          //字符串
•	C、var a =undefined , b =NaN
•	D、var a=NaN , b='undefined'       //”NaNundefined”
27、var a=10; b=20; c=4;  ++b+c+a++ 以下哪个结果是正确的？答案(  B  )
•	A、34   B、35  C、36  D、37
•	//21+4+10
28、typeof运算符返回值中有一个跟javascript数据类型不一致，它是________”function”_________。
29、定义了一个变量，但没有为该变量赋值，如果alert该变量，javascript弹出的对话框中显示___undefined______ 。
30、分析代码，得出正确的结果。
•	var a=10, b=20 , c=30;
•	++a;
•	a++;
•	e=++a+(++b)+(c++)+a++;//一开始：a=12
•	//程序执行时：13+21+30+13：细心
•	alert(e);
•	弹出提示对话框：77
•	var a=10, b=20 , c=30;
•	++a;//a=11
•	a++;//a=11
•	e=++a+(++b)+(c++)+a++;
•	//a=12  13+21+30+13=77
•	alert(e);
31、写出程序运行的结果？
•	for(i=0, j=0; i<10, j<6; i++, j++){
•	k = i + j;}
•	结果：10
•	for(i=0, j=0; i<10, j<6; i++, j++){
•	    //终止条件：j=5 i=5
•	    k = i + j;//k=10
•	}
•	//结果：10
32、阅读以下代码，请分析出结果
•	var arr = new Array(1 ,3 ,5);
•	arr[4]='z';//[1,3,5,undefined,’z’]
•	arr2 = arr.reverse();   //arr2=[’z’,undefined,5,3,1];
•	//arr=[’z’,undefined,5,3,1]
•	arr3 = arr.concat(arr2);
•	alert(arr3);
•	弹出提示对话框：z,,5,3,1,z,,5,3,1
•	考点：reverse 方法
•	1、颠倒数组中元素的位置，
•	2、并返回该数组的引用。
33、给一个按钮绑定点击事件的函数，确认用户是否退出当前页面，确认之后关闭窗口
•	confirm
•	window.close()
34、定义一个foo()函数的内容，要求能够弹出对话框提示当前选中的是第几个单选框。
•	<body>
•	<form name=”form1″ >
•	<input type=”radio” name=”radioGroup” />
•	<input type=”radio” name=”radioGroup”/>
•	<input type=”radio” name=”radioGroup”/>
•	<input type=”radio” name=”radioGroup”/>
•	<input type=”submit”/>
•	</form>
•	</body>
35、列举浏览器对象模型BOM里常用的至少4个对象，并列举window对象的常用方法至少5个
•	对象：window document location screen history navigator
•	方法：alert() confirm() prompt() open() close()
36、简述列举文档对象模型DOM里document的常用的查找访问节点的方法
•	Document.getElementById 根据元素id查找元素
•	Document.getElementByName 根据元素name查找元素
•	Document.getElementTagName 根据指定的元素名查找元素
37、希望获取到页面中所有的checkbox怎么做？(不使用第三方框架)
38、简述创建函数的几种方式
•	第一种（函数声明）：
•	function sum1(num1,num2){
•	   return num1+num2;
•	}
•	第二种（函数表达式）：
•	var sum2 = function(num1,num2){
•	   return num1+num2;
•	}
•	匿名函数：
•	function(){}:只能自己执行自己 
•	第三种（函数对象方式）：了解
•	var sum3 = new Function("num1","num2","return num1+num2");
41、documen.write和 innerHTML 的区别？
•	document.write 只能重绘整个页面
•	innerHTML 可以重绘页面的一部分
43、判断一个字符串中出现次数最多的字符，统计这个次数
•	答：var str = 'asdfssaaasasasasaa';
var json = {};
for (var i = 0; i < str.length; i++) {
        if(!json[str.charAt(i)]){ //str.charAt(i) =”a”
                json[str.charAt(i)] = 1; //json[“a”]=1
        }else{
                json[str.charAt(i)]++; //让a键的值+1，也就是这个字符多出现了一次
        }
};
var iMax = 0;
var iIndex = '';
for(var i in json){
        if(json[i]>iMax){
                iMax = json[i];
                iIndex = i;
        }
}
alert('出现次数最多的是:'+iIndex+'出现'+iMax+'次');
44、写一个获取非行间样式的函数 //内嵌、外联，行内
•	function getStyle(obj,attr,value){
•	  	if(!value){
•	  		if(obj.currentStyle){  //ie
•	  			return obj.currentStyle(attr);
•	  		}else{//标准浏览器
•	  			obj.getComputedStyle(attr,false);
•	  		}
•	  	}else{
•	  		obj.style[attr] = value;
•	  	}
•	  }
45、解释jsonp的原理
•	动态创建script标签，给请求的地址中添加一个get参数，这个参数代表回调函数，也就是希望服务器处理完我的请求之后，在前端执行这个对调函数
46、javascript的本地对象，内置对象和宿主对象
•	本地对象为array obj regexp等可以new实例化
•	Array RegExp String Boolean 。。。
•	内置对象为global、Math 等不可以实例化的
•	关于global对象我们无法在浏览器中发现她的存在，因为他的属性和方法都被绑定在了window对象中
•	每一个宿主对象他的实现都是取决于不同的浏览器的，这样就产生了浏览器兼容性问题
•	宿主为浏览器自带的document,window 等
47、字符串反转，如将 '12345678' 变成 '87654321'
 	•	//大牛做法；
•	//思路：先将字符串转换为数组 split()，利用数组的反序函数 reverse()颠倒数组，再利用 jion() 转换为字符串
•	var str = '12345678';
•	str = str.split('').reverse().join('');
48、window.location.search返回的是什么？
•	    答：查询(参数)部分。除了给动态语言赋值以外，我们同样可以给静态页面,并使用javascript来获得相信应的参数值
•	   返回值：?ver=1.0&id=timlq 也就是问号后面的！
//url:http://www.sina.com/getage?number=1&year=2016
49、window.location.hash 返回的是什么？
•	答：锚点 ， 返回值：#love ；
•	//url:http://www.sina.com/getage?#age
•	这时就返回”#age”
 
50、window.location.reload() 作用？
•	    答：刷新当前页面。
51、看题做答：
 	•	function f1(){
•	    var tmp = 1;
•	    this.x = 3;//window.x=3
•	    console.log(tmp);    //A
•	    console.log(this.x)；     //B
•	}
•	var obj = new f1();  //1 3
•	console.log(obj.x)    //3
•	console.log(f1());     //1 3 undefined
 
52、下面输出多少？
 	•	var o1 = new Object();
•	var o2 = o1;
•	o2.name = "CSSer";
•	console.log(o1.name); //”CSSer”
53、下面代码输出什么
•	function changeObjectProperty (o) {
•	//var o;
•	    //o=CSSer;
•	    o.siteUrl = "http://www.csser.com/";
•	    o = new Object();
•	    o.siteUrl = "http://www.popcg.com/";
•	}
•	var CSSer = new Object();
•	changeObjectProperty(CSSer);
•	console.log(CSSer.siteUrl);  //” http://www.csser.com/”
54、观看代码，有什么输出
 	var a = 6;
setTimeout(function () {    
    var a = 666;//由于变量a是一个局部变量
    alert(a);      // 输出666，
}, 0);
a = 66;
console.log(a);  //先打印全局变量a的值：66  再执行setTimeout里面的局部变量
因为var a = 666;定义了局部变量a，并且赋值为666，根据变量作用域链，
全局变量处在作用域末端，优先访问了局部变量，从而覆盖了全局变量 。
55、看输出结果
 	var a = 6;
setTimeout(function(){
    alert(a);
    var a = 66;
}, 1000);
a = 666;
alert(a);
//结果：666 undefined
56、输出多少？
 	function setN(obj){
    obj.name='**丝';
    obj = new Object(); 
    obj.name = '腐女';
};
var per = new Object();
setN(per);
alert(per.name);  //**丝 内部
57、观察以下代码的输出
 	window.color = 'red';
var o = {color: 'blue'};
function sayColor(){
    alert(this.color);
}
考点：1、this的指向
      2、call的用法
sayColor(); //red
sayColor.call(this); //red this指向的是window对象
sayColor.call(window); //red
sayColor.call(o); //blue
58、结果是什么？
 	function foo(){
    foo.a = function(){alert(1)}; 
    this.a = function(){alert(2)}; //obj.a
    a = function(){alert(3)};
    var a = function(){alert(4)};
}; 
foo.prototype.a = function(){alert(5)};
foo.a = function(){alert(6)};
foo.a(); //6
var obj = new foo();
obj.a(); //2
foo.a(); //1
59、分析代码结果
var a = 5; 
function test(){
   var a; 
  a = 0; 
    alert(a); 
    alert(this.a); //没有定义 a这个属性
        alert(a)
}
test(); // 0, 5, 0
var obj=new test(); // 0, undefined, 0 //由于类它自身没有属性a， 所以是undefined
60、结果是
 	var bool = !!2; alert(bool)；//true;
技巧：双向非操作可以把字符串和数字转换为布尔值。
61、匹配输入的字符：第一个必须是字母或下划线开头，后面就是字母和数字或者下划线构成，长度5-20
 	var reg = /^[a-zA-Z_][a-zA-Z0-9_]{4,19}/,
 
62、BOM对象有哪些，列举window对象？
    1、window对象 ，是JS的最顶层对象，其他的BOM对象都是window对象的属性；
    2、document对象，文档对象；
    3、location对象，浏览器当前URL信息；
    4、navigator对象，浏览器本身信息；
    5、screen对象，客户端屏幕信息；
    6、history对象，浏览器访问历史信息；
63、JS中的简单继承
——>call方法！
 	//顶一个父母类，注意：类名都是首字母大写的哦！
  function Parent(name, money){
            this.name = name;
            this.money = money;
            this.info = function(){
                alert('姓名： '+this.name+' 钱： '+ this.money);
            }
        }
        //定义孩子类
        function Children(name){
            Parent.call(this, name); //继承 姓名属性，不要钱。  
            this.info = function(){
                alert('姓名： '+this.name);
            }
        }
        //实例化类
        var per = new Parent('parent', 800000000000);
        var chi = new Children('child');
        per.info();
        chi.info();
64、bind(), live(), delegate()的区别
    bind： 绑定事件，对新添加的事件不起作用，方法用于将一个处理程序附加到每个匹配元素的事件上并返回jQuery对象。
    live： 方法将一个事件处理程序附加到与当前选择器匹配的所有元素（包含现有的或将来添加的）的指定事件上并返回jQuery对象。
delegate： 方法基于一组特定的根元素将处理程序附加到匹配选择器的所有元素（现有的或将来的）的一个或多个事件上。
最佳实现：jquery 1.7之后：就推荐使用on() off()
65、简述link和import的区别？
区别1：link是XHTML标签，除了加载CSS外，还可以定义RSS等其他事务；@import属于CSS范畴，只能加载CSS。
区别2：link引用CSS时，在页面载入时同时加载；@import需要页面网页完全载入以后加载。
区别3：link是XHTML标签，无兼容问题；@import是在CSS2.1提出的，低版本的浏览器不支持。
区别4：link支持使用Javascript控制DOM去改变样式；而@import不支持。
66、看下列代码输出什么？
var foo = "11"+2-"1";
console.log(foo);
console.log(typeof foo); //“number”
执行完后foo的值为111，foo的类型为Number。
67、看下列代码,输出什么？
var a = new Object();
a.value = 1;
b = a;
b.value = 2;
alert(a.value);
执行完后输出结果为2
68、你如何优化自己的代码？
代码重用：声明函数把整个过程封装起来；把他们弄成一些对象
避免全局变量（命名空间，封闭空间，模块化mvc..） AngularJS
拆分函数避免函数过于臃肿：单一职责原则：条理更加清晰，更好的维护
适当的注释，尤其是一些复杂的业务逻辑或者是计算逻辑，都应该写出这个业务逻辑的具体过程
内存管理，尤其是闭包中的变量释放
变量的命名规范：尤其是在实际项目中
$div：代表一个jquery对象
dom：代表一个原生的dom对象
希望一个函数是构造函数：函数的首字母都要大写
变量一定要语义化：
69、请描述出下列代码运行的结果
function d(){
console.log(this);
}
d();//window
70、请将一个URL的search部分参数与值转换成一个json对象
//search部分的参数格式：a=1&b=2&c=3
function getJsonFromUrlSearch(search){
    var item;
    var result={};
    if(search.indexOf('&')<0){
        item=search.split('=');
        result[item[0]]=item[1];
        return result;
    }
    var splitArray=search.split('&');
    for (var i = 0; i < splitArray.length; i++) {
        var obj = splitArray[i];
        item=obj.split('=');
        result[item[0]]=item[1];
    }
    return result;
}
var c=getJsonFromUrlSearch("a=1&b=2&c=3");
71、请用原生js实现jquery的get\post功能，以及跨域情况下
ajax
先创建一个HttpRequest()
再设置他的请求头：请求的数据类型：json/xml
再设置他的onreadstatechange
最后再提交这个请求
72、请简要描述web前端性能需要考虑哪方面，你的优化思路是什么？
//参见雅虎14web优化规则
//减少http请求：
//1、小图弄成大图（雪碧图、精灵图），
//2、合理的设置缓存 localStorage  cookie
//3、资源合并、压缩 html代码的最小化，压缩体积：就是减少带宽
//    一些小的js文件合并成大的js文件
//将外部的js文件置底
73、简述readyonly与disabled的区别
readonly只针对input(text / password)和textarea有效，
而disabled对于所有的表单元素都有效，当表单元素在使用了disabled后，当我们将表单以POST或GET的方式提交的话，这个元素的值不会被传递出去，而readonly会将该值传递出去
74、请尽可能详尽的解释ajax的工作原理
思路：先解释异步，再解释ajax如何使用
异步是为了进行局部刷新，提升用户体验
2005 年诞生ajax
Ajax的原理简单来说通过XmlHttpRequest对象来向服务器发异步请求，从服务器获得数据，然后用javascript来操作DOM而更新页面。这其中最关键的一步就是从服务器获得请求数据。要清楚这个过程和原理，我们必须对 XMLHttpRequest有所了解。
　XMLHttpRequest是ajax的核心机制，它是在IE5中首先引入的，是一种支持异步请求的技术。简单的说，也就是javascript可以及时向服务器提出请求和处理响应，而不阻塞用户。达到无刷新的效果。
75、为什么扩展javascript内置对象不是好的做法？
因为扩展内置对象会影响整个程序中所使用到的该内置对象的原型属性
//如果说是整个项目中都适用的功能，那么可以进行扩展
76、什么是三元表达式？“三元”表示什么意思？
? :
因为运算符会涉及3个表达式
var a=3>2?5:2;
77、module(12,5)//2  实现满足这个结果的module函数
function module(a,b){
    return a%b;//return a/b;
}
78、HTTP协议中，GET和POST有什么区别？分别适用什么场景 ？
get传送的数据长度有限制，post没有
get通过url传递，在浏览器地址栏可见，post是在报文中传递
适用场景：
post一般用于表单提交
get一般用于简单的数据查询，严格要求不是那么高的场景
79、HTTP状态消息200 302 304 403 404 500分别表示什么
200：请求已成功，请求所希望的响应头或数据体将随此响应返回。
302：请求的资源临时从不同的 URI响应请求。由于这样的重定向是临时的，客户端应当继续向原有地址发送以后的请求。只有在Cache-Control或Expires中进行了指定的情况下，这个响应才是可缓存的
304：如果客户端发送了一个带条件的 GET 请求且该请求已被允许，而文档的内容（自上次访问以来或者根据请求的条件）并没有改变，则服务器应当返回这个状态码。304响应禁止包含消息体，因此始终以消息头后的第一个空行结尾。
403：服务器已经理解请求，但是拒绝执行它。
404：请求失败，请求所希望得到的资源未被在服务器上发现。
500：服务器遇到了一个未曾预料的状况，导致了它无法完成对请求的处理。一般来说，这个问题都会在服务器端的源代码出现错误时出现。
80、HTTP协议中，header信息里面，怎么控制页面失效时间（last-modified,cache-control,Expires分别代表什么）
Last-Modified
文档的最后改动时间。客户可以通过If-Modified-Since请求头提供一个日期，该请求将被视为一个条件GET，只有改动时间迟于指定时间的文档 才会返回，否则返回一个304（Not Modified）状态。Last-Modified也可用setDateHeader方法来设置。
Expires
应该在什么时候认为文档已经过期，从而不再缓存它？
81、请列举js数组类型中的常用方法
•	方法
•	描述
•	concat()
•	连接两个或更多的数组，并返回结果。
•	join()
•	把数组的所有元素放入一个字符串。元素通过指定的分隔符进行分隔。
•	pop()
•	删除并返回数组的最后一个元素
•	push()
•	向数组的末尾添加一个或更多元素，并返回新的长度。
•	reverse()
•	颠倒数组中元素的顺序。
•	shift()
•	删除并返回数组的第一个元素
•	slice()
•	从某个已有的数组返回选定的元素
•	sort()
•	对数组的元素进行排序
•	splice()
•	删除元素，并向数组添加新元素。
•	toSource()
•	返回该对象的源代码。
•	toString()
•	把数组转换为字符串，并返回结果。
•	toLocaleString()
•	把数组转换为本地数组，并返回结果。
•	unshift()
•	向数组的开头添加一个或更多元素，并返回新的长度。
•	valueOf()
•	返回数组对象的原始值
82、列举常用的js框架以及分别适用的领域
•	jquery：简化了js的一些操作，并且提供了一些非常好用的API
•	jquery ui、jquery-easyui：在jqeury的基础上提供了一些常用的组件 日期，下拉框，表格这些组件
•	require.js、sea.js（阿里的玉帛）+》模块化开发使用的
•	jquery mobile：是jquery自己出的支持移动端网页开发，不过非常笨重，但是功能非常强大
•	zepto：精简版的jquery，常用于手机web前端开发 提供了一些手机页面实用功能,touch 
•	ext.js：跟jquery差不多，但是不开源，也没有jquery轻量
•	angular、knockoutjs、avalon(去哪儿前端总监，作者：司徒正美)：MV*框架，适合用于单页应用开发(SPA)
83、如何获取对象a拥有的所有属性（可枚举的、不可枚举的，不包括继承来的属性）
•	Object.keys——IE9+ ES5
•	或者使用for…in并过滤出继承的属性
•	for(o in obj){
•	  if(obj.hasOwnproperty(o)){//判断o不是继承来的属性
•	    //把o这个属性放入到一个数组中
•	}
•	}
84、下面这段代码想要循环昝输出结果01234，请问输出结果是否正确，如果不正确，请说明为什么，并修改循环内的代码使其输出正确结果
•	for(var i=0;i<5;++i){
•	setTimeout(function(){
•	console.log(i+’’);
•	},100*i);
•	}
85、解释下这个css选择器什么发生什么？
•	[role=nav]>ul a:not([href^-mailto]){}
89、三种弹窗的单词以及三种弹窗的功能
•	alert
•	confirm
•	prompt
91、写一个post请求并带有发送数据和返回数据的样例
•	$.ajax({
•	    url:"1.html",
•	    data:{name:"张三",age:18},//post数据
•	    dataType:"json",
•	    type:"POST",
•	    success:function(data){
•	        //data：返回的数据
•	    },
•	    error:function(){
•	        //异常处理
•	    }
•	});
90、jQuery框架中$.ajax()的常用参数有哪些？
•	type
•	类型：String
•	默认值: "GET")。请求方式 ("POST" 或 "GET")， 默认为 "GET"。注意：其它 HTTP 请求方法，如 PUT 和 DELETE 也可以使用，但仅部分浏览器支持。
•	url
•	类型：String
•	默认值: 当前页地址。发送请求的地址。
•	success
•	类型：Function
•	请求成功后的回调函数。
•	参数：由服务器返回，并根据 dataType 参数进行处理后的数据；描述状态的字符串。
•	这是一个 Ajax 事件。
•	Options
•	类型：Object
•	可选。AJAX 请求设置。所有选项都是可选的。
•	async
•	类型：Boolean
•	默认值: true。默认设置下，所有请求均为异步请求。如果需要发送同步请求，请将此选项设置为 false。
•	注意，同步请求将锁住浏览器，用户其它操作必须等待请求完成才可以执行。
•	beforeSend(XHR)
•	类型：Function
•	发送请求前可修改 XMLHttpRequest 对象的函数，如添加自定义 HTTP 头。
•	XMLHttpRequest 对象是唯一的参数。
•	这是一个 Ajax 事件。如果返回 false 可以取消本次 ajax 请求。
•	cache
•	类型：Boolean
•	默认值: true，dataType 为 script 和 jsonp 时默认为 false。设置为 false 将不缓存此页面。
•	jQuery 1.2 新功能。
•	contentType
•	类型：String
•	默认值: "application/x-www-form-urlencoded"。发送信息至服务器时内容编码类型。
•	默认值适合大多数情况。如果你明确地传递了一个 content-type 给 $.ajax() 那么它必定会发送给服务器（即使没有数据要发送）。
•	data
•	类型：String
•	发送到服务器的数据。将自动转换为请求字符串格式。GET 请求中将附加在 URL 后。查看 processData 选项说明以禁止此自动转换。必须为Key/Value 格式。如果为数组，jQuery 将自动为不同值对应同一个名称。如 {foo:["bar1", "bar2"]} 转换为 '&foo=bar1&foo=bar2'。
•	dataFilter
•	类型：Function
•	给 Ajax 返回的原始数据的进行预处理的函数。提供 data 和 type 两个参数：data 是 Ajax 返回的原始数据，type 是调用 jQuery.ajax 时提供的dataType 参数。函数返回的值将由 jQuery 进一步处理。
•	dataType
•	类型：String
•	预期服务器返回的数据类型。如果不指定，jQuery 将自动根据 HTTP 包 MIME 信息来智能判断，比如 XML MIME 类型就被识别为 XML。在 1.4中，JSON 就会生成一个 JavaScript 对象，而 script 则会执行这个脚本。随后服务器端返回的数据会根据这个值解析后，传递给回调函数。可用值:
•	· "xml": 返回 XML 文档，可用 jQuery 处理。
•	· "html": 返回纯文本 HTML 信息；包含的 script 标签会在插入 dom 时执行。
•	· "script": 返回纯文本 JavaScript 代码。不会自动缓存结果。除非设置了 "cache" 参数。注意：在远程请求时(不在同一个域下)，所有 POST 请求都将转为 GET 请求。（因为将使用 DOM 的 script标签来加载）
•	· "json": 返回 JSON 数据 。
•	· "jsonp": JSONP 格式。使用 JSONP 形式调用函数时，如 "myurl?callback=?" jQuery 将自动替换 ? 为正确的函数名，以执行回调函数。
•	· "text": 返回纯文本字符串
•	error
•	类型：Function
•	默认值: 自动判断 (xml 或 html)。请求失败时调用此函数。
•	有以下三个参数：XMLHttpRequest 对象、错误信息、（可选）捕获的异常对象。
•	如果发生了错误，错误信息（第二个参数）除了得到 null 之外，还可能是 "timeout", "error", "notmodified" 和 "parsererror"。
•	这是一个 Ajax 事件。
•	92、闭包：下面这个ul，如何点击每一列的时候alert其index？
•	<ul id="test">
•	<li>这是第一条</li>
•	<li>这是第二条</li>
•	<li>这是第三条</li>
•	</ul>
•	//非闭包实现
•	var lis=document.querySelectorAll('li');
•	document.querySelector('#test').onclick=function(e){
•	    for (var i = 0; i < lis.length; i++) {
•	        var li = lis[i];
•	        if(li==e.target){
•	            alert(i);
•	        }
•	    }
•	};
•	//闭包实现
•	var lis=document.querySelectorAll('li');
•	for (var i = 0; i < lis.length; i++) {
•	    var li = lis[i];
•	    li.onclick=(function(index){
•	         return function(e){
•	            alert(index);
•	        };
•	    })(i);
•	}
93、Javascript中callee和caller的作用？
•	caller是返回一个对函数的引用，该函数调用了当前函数；
•	用法：fn.caller
•	callee是返回正在被执行的function函数，也就是所指定的function对象的正文。
•	用法：arguments.callee
94、在Javascript中什么是伪数组？如何将伪数组转化为标准数组？
•	伪数组（类数组）：无法直接调用数组方法或期望length属性有什么特殊的行为，但仍可以对真正数组遍历方法来遍历它们。典型的是函数的argument参数，还有像调用getElementsByTagName,document.childNodes之类的,它们都返回NodeList对象都属于伪数组。
•	可以使用Array.prototype.slice.call(fakeArray)将数组转化为真正的Array对象。
95、《正则》写出正确的正则表达式匹配固话号，区号3-4位，第一位为0，中横线，7-8位数字，中横线，3-4位分机号格式的固话号
•	常用正则表达式语法要熟悉
•	/0[0-9]{2,3}-\d{7,8}/  010 021 020 025 028 0755：深圳
128、jQuery 的 slideUp动画 ，如果目标元素是被外部事件驱动, 当鼠标快速地连续触发外部元素事件, 动画会滞后的反复执行，该如何处理呢?
•	先stop(true,true)后slideUp()
•	示例代码参考：J:\代码,PPT,笔记,电子书\面试题\面试题_jquery_slideup.html
•	关于stop()参考：J:\代码,PPT,笔记,电子书\面试题\面试题_jquery.png
129、Ajax 是什么? 如何创建一个Ajax？
•	Ajax并不算是一种新的技术，全称是asynchronous javascript and xml，可以说是已有技术的组合，主要用来实现客户端与服务器端的异步通信效果，实现页面的局部刷新，早期的浏览器并不能原生支持ajax，可以使用隐藏帧（iframe）方式变相实现异步效果，后来的浏览器提供了对ajax的原生支持
•	使用ajax原生方式发送请求主要通过XMLHttpRequest(标准浏览器)、ActiveXObject(IE浏览器)对象实现异步通信效果
•	基本步骤：
•	var xhr =null;//创建对象 
•	if(window.XMLHttpRequest){
•	xhr = new XMLHttpRequest();
•	}else{
•	xhr = new ActiveXObject("Microsoft.XMLHTTP");
•	}
•	     xhr.open(“方式”,”地址”,”标志位”);//初始化请求 
•	     xhr.setRequestHeader(“”,””);//设置http头信息 
•	     xhr.onreadystatechange =function(){}//指定回调函数 
•	     xhr.send();//发送请求 
130、同步和异步的区别?
•	同步：阻塞的
•	-张三叫李四去吃饭，李四一直忙得不停，张三一直等着，直到李四忙完两个人一块去吃饭
•	=浏览器向服务器请求数据，服务器比较忙，浏览器一直等着（页面白屏），直到服务器返回数据，浏览器才能显示页面
•	异步：非阻塞的
•	-张三叫李四去吃饭，李四在忙，张三说了一声然后自己就去吃饭了，李四忙完后自己去吃
•	=浏览器向服务器请求数据，服务器比较忙，浏览器可以自如的干原来的事情（显示页面），服务器返回数据的时候通知浏览器一声，浏览器把返回的数据再渲染到页面，局部更新
131、GET和POST的区别，何时使用POST？
•	GET：一般用于信息获取，使用URL传递参数，对所发送信息的数量也有限制，一般在2000个字符，有的浏览器是8000个字符
•	POST：一般用于修改服务器上的资源，对所发送的信息没有限制
•	在以下情况中，请使用 POST 请求：
•	1. 无法使用缓存文件（更新服务器上的文件或数据库）
•	2. 向服务器发送大量数据（POST 没有数据量限制）
•	3. 发送包含未知字符的用户输入时，POST 比 GET 更稳定也更可靠
132、ajax的缺点
•	 1、ajax不支持浏览器back按钮。
•	 2、安全问题 AJAX暴露了与服务器交互的细节。
•	 3、对搜索引擎的支持比较弱。//不会执行你的js脚本，只会操作你的网页源代码
•	 4、破坏了程序的异常机制。
•	 5、无法跨域请求，解决方式：jsonp
133、http常见的状态码有那些？分别代表是什么意思？
•	200 OK      //客户端请求成功
•	400 Bad Request  //客户端请求有语法错误，不能被服务器所理解
•	403 Forbidden  //服务器收到请求，但是拒绝提供服务
•	404 Not Found  //请求资源不存在，输入了错误的URL
•	500 Internal Server Error //服务器发生不可预期的错误
•	503 Server Unavailable  //服务器当前不能处理客户端的请求，一段时间后可能恢复正常
135、new操作符具体干了什么呢?
•	1、创建一个空对象，并且 this 变量引用该对象，同时还继承了该函数的原型。
•	 2、属性和方法被加入到 this 引用的对象中。
•	 3、新创建的对象由 this 所引用，并且最后隐式的返回 this 。

